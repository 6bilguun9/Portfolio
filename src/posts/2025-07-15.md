---
title: "Wrapped Up Sorting Algorithms and Built a Binary Search Tree from Scratch"
date: "2025-07-15"
---

## 📚 What I Worked On

This week I wrapped up studying **sorting algorithms** and took a deep dive into **binary search trees** — writing my own BST from scratch in Java. No shortcuts, no libraries — just me versus the logic.

I implemented all the classics:

- Bubble Sort
- Insertion Sort
- Selection Sort
- Merge Sort
- Quick Sort

Then I built a full-on BST with:

- Insert (iterative and recursive)
- Remove (both versions — and yes, iterative delete was a war)
- Min/max find
- In-order traversal
- Duplicate handling
- Generic support using `T extends Comparable<T>`

This wasn’t about getting it done fast. It was about **doing it right** — and proving to myself that I can build hard things without running.

---

## 💡 Why It Matters

These are the kind of fundamentals that **gritty engineers** master. Not just for interviews — but for writing scalable, performant systems in the real world.

Sorting and binary trees are everywhere: databases, file systems, compilers, AI models — you name it. And sure, libraries can abstract the hard parts. But I don’t want to be someone who hides behind the abstraction.

I want to be someone who understands it all the way down.

---

## ⚔️ What Was Hard

BST `remove()` — especially the **iterative version** — was the hardest thing I’ve built in weeks.

Recursive delete? Elegant.  
Iterative delete? Chaos.

Tracking parent pointers, handling the 3-case logic, keeping the tree structure intact — it was frustrating, it was slow, and I almost gave up on it. But I didn’t.

That’s where **grit** came in. I pushed through not because it was easy, but because it wasn’t.

Same thing with making the tree generic — `T extends Comparable<T>` — and writing insert/remove in two different styles. It stretched my understanding of Java's type system, and it made me sharper.

---

## 🚀 What’s Next

Now that sorting and trees are locked in, I’m moving on to:

- Tree traversals (in-order, pre-order, post-order, level-order)
- Size and height functions
- Balance checking
- Eventually: AVL and Red-Black Trees

I’m also starting to think about how to turn this into a UI or live data tool — something visual that proves I get both **structure and function**.

---

### 🧠 Final Thought

I’m not trying to be perfect.  
I’m trying to be **gritty** — the kind of person who builds, fixes, breaks, and builds again.  
Because in the long run, grit beats talent. Every. Time.
