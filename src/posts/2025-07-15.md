---
title: "Wrapped Up Sorting Algorithms and Built a Binary Search Tree from Scratch"
date: "2025-07-15"
---

## ğŸ“š What I Worked On

This week I wrapped up studying **sorting algorithms** and took a deep dive into **binary search trees** â€” writing my own BST from scratch in Java. No shortcuts, no libraries â€” just me versus the logic.

I implemented all the classics:

- Bubble Sort
- Insertion Sort
- Selection Sort
- Merge Sort
- Quick Sort

Then I built a full-on BST with:

- Insert (iterative and recursive)
- Remove (both versions â€” and yes, iterative delete was a war)
- Min/max find
- In-order traversal
- Duplicate handling
- Generic support using `T extends Comparable<T>`

This wasnâ€™t about getting it done fast. It was about **doing it right** â€” and proving to myself that I can build hard things without running.

---

## ğŸ’¡ Why It Matters

These are the kind of fundamentals that **gritty engineers** master. Not just for interviews â€” but for writing scalable, performant systems in the real world.

Sorting and binary trees are everywhere: databases, file systems, compilers, AI models â€” you name it. And sure, libraries can abstract the hard parts. But I donâ€™t want to be someone who hides behind the abstraction.

I want to be someone who understands it all the way down.

---

## âš”ï¸ What Was Hard

BST `remove()` â€” especially the **iterative version** â€” was the hardest thing Iâ€™ve built in weeks.

Recursive delete? Elegant.  
Iterative delete? Chaos.

Tracking parent pointers, handling the 3-case logic, keeping the tree structure intact â€” it was frustrating, it was slow, and I almost gave up on it. But I didnâ€™t.

Thatâ€™s where **grit** came in. I pushed through not because it was easy, but because it wasnâ€™t.

Same thing with making the tree generic â€” `T extends Comparable<T>` â€” and writing insert/remove in two different styles. It stretched my understanding of Java's type system, and it made me sharper.

---

## ğŸš€ Whatâ€™s Next

Now that sorting and trees are locked in, Iâ€™m moving on to:

- Tree traversals (in-order, pre-order, post-order, level-order)
- Size and height functions
- Balance checking
- Eventually: AVL and Red-Black Trees

Iâ€™m also starting to think about how to turn this into a UI or live data tool â€” something visual that proves I get both **structure and function**.

---

### ğŸ§  Final Thought

Iâ€™m not trying to be perfect.  
Iâ€™m trying to be **gritty** â€” the kind of person who builds, fixes, breaks, and builds again.  
Because in the long run, grit beats talent. Every. Time.
